
# Project description 

[TOC]

## Introduction

This is a sample repo with one flow (`test_<step>`, where <step> is a number) that tries to exemplify how you build a working app progressively; each `test_*` flow is a step based on previous one towards the final app model.

If you are here it means you successfully cloned the project into AEP GUI; congratulations :clap: !

# #Deployment view - components

This project uses the following components:

- http server gw to allow incoming http requests
- rte component that runs the service flows 
- http client gw to allow to send http requests to other servers from the flows 
- cdr gw to allow generating cdrs 
- timer gw to allow to set timers cross-cluster and wake up sessions 

> :point_left: These components can be seen at `Runtime view` / `Processes` in the left menu sidebar

Also, we make use of the api at https://bored.api.lewagon.com/api/activity , so you must be able to access from VM this public internet site.

The sequence diagram of this sample application/service is the following:
```
sequenceDiagram
    curl->>httpserver: http get quote
    httpserver->>rte: process event
    loop Until participants more than 1
        rte->>httpclient: initiate request
        httpclient->>external_api: http get activity
        external_api-->>httpclient: http response
        httpclient-->>rte: process event 
        rte->>rte: check required participants
        Note right of rte: if less than 2 participants <br/>sleep and request a new activity
        rte->>timer: set timer if less than 2 participants to try again for a new activity
    end
    rte->>cdr: generate_cdr
    rte-->>httpserver: send response
    httpserver-->>curl: http response
```

Basically, the ideea of the application is the following:

1. you are bored and you ask the service to suggest an activity (you can do it via `curl` or any other http client, even your browser)
2. `http server gw` will receive your request, will trigger the `rte` that will run in turn our application / flow
3. the application will make a request to an external web service (on internet) that will send back a suggestion of an activity to perform and the expected number of participants for this activity
4. if the number of participants is 1 (solitary activity) the application will wait 1 sec and request again a new suggestion; until we receive back an activity requiring several participants
5. when we receive an activity with more than 1 participant, we will generate a cdr and reply back to original http request 

> Note: `http server gw` has a limit to wait for a response from `rte`; if `rte` (including running unspecified number of loops at step 4) is taking longer to 
respond, `http server gw` will reply back to http client with status 504 (so you can see status 504 in curl command, but this is normal; check traces or increase timeout in `http server gw`) 

## What do to first

1. select namespace `test` 
2. go to Design/Libraries and upload all libraries into runtime (all labels should be green)
3. go to Environment settings/Ingress queues and for queue name `dispatch-script` select the dispatch lib `generic-dispatch` from drop down box
4. go to Design/Flows and upload all flows into runtime (all labels should be green)
5. go to "Flow test data"  and select the queuedb (only one option in drop down box) plus the rte instance (`queue name` drop down box; there will be several entries, select the one that starts with `rte`)

Now you are good to go :fireworks: ! 

## Test step 1 

In this step, you will execute flow test_1 which does not do anything; but it shows how you can do tracing. 

```bash
curl -k "https://web.aep.qsrlab.io:8443/test?flowname=test:induction:test_1"
```

Go to AEP GUI, Runtime View (left side menu), Traces and from drop down box `Flows?` select the flow `induction:test_1` and in the table you should see a row for each session that used this flow. 

Select it (left side buttons on the table row) to see the traces either as a list or as a diagram. 

### See traces as a list

When you check the session tracing in list mode, for each state traversed by the session there is a row; selecting the row it shows the full context used at that time during execution (current event, current session, any errors, etc).

Red lines are incoming events from external systems and blue lines are responses generated by AEP or new requests to external systems made by AEP. 

Select the first line and check the "initial"  slot in the JSON editor; this is the actual event after decoding and pre-processing that AEP receives. 

In this way you can learn the structure of events iteratively; we encourage an exploratory development style. 

### See traces as a diagram

When you check session tracing in diagram mode, the states traversed by the session during execution are highlighted in green; you can select a state and right click on it, press "View session" in the 
context menu to see again the full info about state of engine during execution at this point. 


Now that you can check the structure of event you receive (fields, values, etc), let's go forward and look at the next step

## Test step 2

In this step, we will execute the flow "test_2"; you can open it up (left side menu, Design/Flows and press the open button on the row). 

Run the statement:

```bash
curl -k "https://web.aep.qsrlab.io:8443/test?flowname=test:induction:test_2"
```

You should receive back the proverbial "Hello World!" message! 

Go ahead and check the trace as well as comments in the flow diagram! 

What you should pay attention to this time:

1. check again the tracing and context available at each state to see how session content changed 
2. we use a new handler for building objects and storing them into session so that they are available as long as session exists; these objects can be created in one instance and available in all other instances, per session. 

## Test step 3

Now, we will actually invoke an [external API](https://www.boredapi.com/api/activity) . 

```bash
curl -k "https://web.aep.qsrlab.io:8443/test?flowname=test:induction:test_3"
```

You should receive back a suggestion how to spend your free time (and no, it is not suggesting to work at computer :smile: ). If there is no network connection to internet, an error will be received. 

Again, check the traces, look at comments in the flow diagram; important points:

1. this step demonstrates how engine takes different paths based on the event received 
2. also it shows how to use [SpEL expressions](https://docs.spring.io/spring-framework/docs/3.0.x/reference/expressions.html) to navigate in the object hierarchies and use java syntax to change at runtime the execution context

## Test step 4

We try to look into API response and check if the activity is fit for more than 1 participant; if it requires only one participant
we will wait 1 second and try again. 

At this step:

1. we see how we can take decisions based on event fields (same for sessions or local params fields)
2. we see how we can use SPEL 
3. and we see tracing when there is an error in the flow 

> In trace based on diagram, the shape with error is highlighted in orange or red (depending on severity) and when you check the contect you will see also the error described.

How to invoke:

```shell
curl -k "https://web.aep.qsrlab.io:8443/test?flowname=test:induction:test_4"
```

## Test step 5

Now we have a flow that is almost complete; we added a loop to ask for a suggestion until either we receive a valid (requiring more people) or loop counter is
exceeded. 

> Notice that we fixed the error in step 4 

If it is exceeded, we return http 404 (not found) and a short message describing the situation. 

```shell
curl -k "https://web.aep.qsrlab.io:8443/test?flowname=test:induction:test_5"
```

## Test step 6 - how state machine works

We add a CDR handler ; this will generate a cdr file containing the response sent to the http client (for the purpose of test). More importantly, it will give
us a chance to discuss how the engine moves from one state to another. 

### How state machine works and transitions from one state to another are selected

The state machine is permanently waiting for events; when an event comes, and the state machine to execute is selected via `dispatch script`, we will do the following steps:
1. check if there is a session and if it is, restore the state machine (position the current state) to the state stored in the session (so it can continue where it left off). If there is no session, it means there is no stored current state, and we automatically
select the start state as current state. 
2. once we have a current state, we compare the transitions (outgoing arrows) with the event name and apply the following algorithm, in this order;
    - exact match between event name and label on the arrow; if a match is found, we will follow that transition and move the current state to the end of arrow
    - most specific match when using `text.*` (i.e. `http.*` for example)
    - "*" matches any event
    - if there is an arrow/transition without any label on it, it will be followed (as last option) even if there is no event. 
3. the state machine will apply repeatedly step 2, following transition/arrows and executing states, until it cannot match any more any transitions or it reaches a final state
    - when it cannot match any transition, but not in final state, we call this that state machine is **stabilized**; the engine will park in redis the session (so that it can be restored when an event comes, possibly on 
    another instance of rte)
    - when it reaches final state, either STOP or a state marked with parameter `isfinal` set to `yes`, the state machine terminates. 

### When the answer is sent back 

As the flow progresses/traverses states, each state executes and may compute a response; however, the state machine is only sending back the response when it is stabilized or when it is reaching a final state.
By default, the engine will only send back one response (or one outgoing message), and this is the last response computed while traversing the states. So in normal configuration, 
if you have one http response handler (that builds actually an http response) followed by an empty (no label) transition and a cdr handler (asking to generate a cdr), the http response handler output
is lost, because it is overwriten by the cdr handler; state machine will retain the last request/command/output message. 

In order to avoid this, you must use `continue` parameter with value `yes`, that will actually instruct the state machine to first send the response and immediately after continue the flow. In this way, 
based on previous example, the http response will be sent, than transition is followed, cdr handler request is build, and when reaching the stop state, this cdr request is sent as well.

## Next ....

We will add:

1. how to modify dispatch events to flows; so far we "cheated" because we put a hint in the request to indicate what flow to execute (query param "flowname"); but this 
is only for demonstration; in fact, the AEP platform is able to receive an event and decide automatically what flow to start executing 
2. how to use data model handlers to save/retrieve data across sessions 
3. how to generate cdrs ()


## SOAP - later addition

In order to use SOAP 1.1 or SOAP 1.2 based on WSDL 1.1, one must do the following steps:

1. import the WSDL via `Custom palettes` menu; the application will create a palette drawer for each operation in the specified binding
2. the WSDL file must be available from GUI backend server (where `nexus-gui-backend` is runing), from http client gateway and from http server gateway. 
  - The best idea is to have a central http server serving WSDL files (let's say a nginx instance) and all apps can use the same URL to access the WSDL. 
  - Alternatively, you can put the WSDL file in the same location on all servers; if you have several gateways on different servers, you must copy the file everywhere
3. you must configure the http server gateway to process SOAP; same HTTP server gateway may handle several SOAP services and non-SOAP services in parallel, so 
you need to specify:
  - which URLs are asigned to SOAP requests; for these URLs the server gateway will treat requests as SOAP and will attempt to decode it based on WSDL specs
  - which binding from WSDL to use based on `Content-Type` http header
  - which operation from WSDL to use based on `soap action`; soap action is retrieved from http header `SOAPAction` (in case of SOAP 1.1) or http header `Content-Type` (in case of SOAP 1.2); if no `soap action` is specified, you can configure a defualt operation to use 
  - here is a sample of `soap` section added to http server config; it specified both default operation (`none`) as well as `sendSms` action to operation mapping. 
```shell
"soap": {
    "/gp/services/SendSmsPx21": {
        "wsdl": "http://ip:port/projects/common/induction/palette/sms.wsdl_SendSmsBinding.wsdl",
        "content-type": {
            "text/xml": "SendSmsBinding"
        },
        "soap-action": {
            "none": "sendSms",
            "sendSms":"sendSms"
        }
    }
},
```
  - replace `ip` and `port` with your server `ip` and `port` (where gui is running)

4. You can use the new palette shapes that are generated after point 1 to build a new flow
    - for responding to soap requests (act as a server) you must configure http server gateway as per point 3 above
    - for making soap requests and receiving back answers, there is no special configuration to do excepting 1 and 2 above. 

> note: the example configured here (and the palette already imported in this project) assumes the wsdl file is in `/tmp/sms.wsdl`. You probably need to make sure it is everywhere.

that's all

