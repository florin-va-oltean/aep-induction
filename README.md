# Introduction

This is a sample repo with one flow (`test_<step>`, where <step> is a number) that tries to exemplify how you build a functional app progressively. 

If you are here it means you successfully cloned the project into AEP GUI; congratulations!

# Deployment view - components

This project uses the following components:

- http server gw to allow incoming http requests
- rte component that runs the service flows 
- http client gw to allow to send http requests to other servers from the flows 
- cdr gw to allow generating cdrs 
- timer gw to allow to set timers cross-cluster and wake up sessions 

> These components can be seen at 

Also, we make use of the api at https://www.boredapi.com/api/activity , so you must be able to access from VM this public internet site.

The diagram is the following:

```
sequenceDiagram
    curl->>httpserver: http get quote
    httpserver->>rte: process event
    loop Until participants more than 1
        rte->>httpclient: initiate request
        httpclient->>external_api: http get activity
        external_api-->>httpclient: http response
        httpclient-->>rte: process event 
        rte->>rte: check required participants
        Note right of rte: if less than 2 participants sleep and request a new activity
        rte->>timer: set timer if less than 2 participants to try again for a new activity
    end
    rte->>cdr: generate_cdr
    rte-->>httpserver: send response
    httpserver-->>curl: http response


```

# What do to first

1. select namespace `test` 
2. go to Design/Libraries and upload all libraries into runtime (all labels should be green)
3. go to Environment settings/Ingress queues and for queue name `dispatch-script` select the dispatch lib `generic-dispatch` from drop down box
4. go to Design/Flows and upload all flows into runtime (all labels should be green)
5. go to "Flow test data"  and select the queuedb (only one option in drop down box) plus the rte instance (`queue name` drop down box; there will be several entries, select the one that starts with `rte`)

Now you are good to go! 

# Test step 1 

In this step, you will execute flow test_1 which does not do anything; but it shows how you can do tracing. 

```bash
curl -k "https://10.211.55.4:8883/test?flowname=test:induction:test_1"
```

Go to AEP GUI, Runtime View (left side menu), Traces and from drop down box `Flows?` select the flow `induction:test_1` and in the table you should see a row for each session that used this flow. 

Select it (left side buttons on the table row) to see the traces either as a list or as a diagram. 

## As a list

When you check the session tracing in list mode, for each state traversed by the session there is a row; selecting the row it shows the full context used at that time during execution (current event, current session, any errors, etc).

Red lines are incoming events from external systems and blue lines are responses generated by AEP or new requests to external systems made by AEP. 

Select the first line and check the "initial"  slot in the JSON editor; this is the actual event after decoding and pre-processing that AEP receives. 

In this way you can learn the structure of events iteratively; we encourage an exploratory development style. 

## As a diagram

When you check session tracing in diagram mode, the states traversed by the session during execution are highlighted in green; you can select a state and right click on it, press "View session" in the 
context menu to see again the full info about state of engine during execution at this point. 


Now that you can check the structure of event you receive (fields, values, etc), let's go forward and look at the next step

# Test step 2

In this step, we will execute the flow "test_2"; you can open it up (left side menu, Design/Flows and press the open button on the row). 

Run the statement:

```bash
curl -k "https://10.211.55.4:8883/test?flowname=test:induction:test_2"
```

You should receive back the proverbial "Hello World!" message! 

Go ahead and check the trace as well as comments in the flow diagram! 

What you should pay attention to this time:

1. check again the tracing and context available at each state to see how session content changed 
2. we use a new handler for building objects and storing them into session so that they are available as long as session exists; these objects can be created in one instance and available in all other instances, per session. 

# Test step 3

Now, we will actually invoke an [external API](https://www.boredapi.com/api/activity) . 

```bash
curl -k "https://10.211.55.4:8883/test?flowname=test:induction:test_3"
```

You should receive back a suggestion how to spend your free time (and no, it is not suggesting to work at computer :smile: ). If there is no network connection to internet, an error will be received. 

Again, check the traces, look at comments in the flow diagram; important points:

1. this step demonstrates how engine takes different paths based on the event received 
2. also it shows how to use [SpEL expressions](https://docs.spring.io/spring-framework/docs/3.0.x/reference/expressions.html) to navigate in the object hierarchies and use java syntax to change at runtime the execution context

# Test step 4

We try to look into API response and check if the activity is fit for more than 1 participant; if it requires only one participant
we will wait 1 second and try again. 

At this step:

1. we see how we can take decisions based on event fields (same for sessions or local params fields)
2. we see how we can use SPEL 
3. and we see tracing when there is an error in the flow 

How to invoke:

```shell
curl -k "https://10.211.55.4:8883/test?flowname=test:induction:test_4"
```


# Next ....

We will add:

1. how to modify dispatch events to flows; so far we "cheated" because we put a hint in the request to indicate what flow to execute (query param "flowname"); but this 
is only for demonstration; in fact, the AEP platform is able to receive an event and decide automatically what flow to start executing 
2. how to use data model handlers to save/retrieve data across sessions 
3. how to use other features like timers, cdrs, logs, query databases, etc. 

